---
# SPDX-FileCopyrightText: Copyright (C) 2021 ale5000
# SPDX-License-Identifer: LGPL-3.0-or-later
# SPDX-FileType: SOURCE

name: "TEST"
author: "ale5000"
description: "GitHub action to execute a lint check of all shell scripts using ShellCheck."
branding:
  icon: "check-circle"
  color: "green"

inputs:
  shellcheck-version:
    description: "Version of ShellCheck to use. Values: [stable, latest, v0.7.2, ...]."
    required: false
    default: "stable"
  severity:
    description: "Minimum severity of issues to display. Values: [style, info, warning, error]."
    required: false
    default: "style"
  enable-all-opt-checks:
    description: "Enable all optional checks. Values: [true, false]"
    required: false
    default: "false"
  ignore-files:
    description: "List of files to ignore, the separator is |"
    required: false
outputs:
  num-files-wth-issues:
    description: "Number of files with issues"
    value: "${{ steps.shellcheck-scan.outputs.numfileswithissues }}"
  path-files-with-issues:
    description: "A list of files with issues"
    value: "${{ steps.shellcheck-scan.outputs.pathfileswithissues }}"
runs:
  using: "composite"
  steps:
    - name: "Set up matcher"
      shell: bash
      run: |
        # Setting up matcher...
        matcher_file="${{ github.action_path }}/.github/matchers/tty/shellcheck-matcher-colors.json"
        if test -f "${matcher_file}"; then echo "::add-matcher::${matcher_file}"; echo 'Matcher configured.'; fi
    - name: "Download ShellCheck"
      shell: bash
      run: |
        # Downloading ShellCheck...
        BASE_LINE='49'
        annotate_error() { LINE="$(("${BASH_LINENO[0]}"+"${BASE_LINE}"-2))"; echo "::error::Error $1 in action.yml at line ${LINE}"; exit "$1"; }

        case "${{ runner.os }}" in 'Linux') current_os='linux';; 'macOS') current_os='darwin';; 'Windows') current_os='win';; *) annotate_error 1; esac
        action_path="${{ github.action_path }}"
        sc_ver="${{ inputs.shellcheck-version }}"
        base_url="https://github.com/koalaman/shellcheck/releases/download/${sc_ver?}/"
        if test "${current_os}" = 'win'; then archive_name="shellcheck-${sc_ver?}.zip"; else archive_name="shellcheck-${sc_ver?}.${current_os?}.x86_64.tar.xz"; fi

        ## Installing wget (only on Windows)...
        if test "${current_os}" = 'win'; then choco install --no-progress --yes wget 1>/dev/null || annotate_error 2; fi

        wget -q -O "${archive_name?}" "${base_url?}${archive_name?}" || annotate_error 3
        if test "${current_os}" = 'win'; then
          unzip -ojq "${archive_name?}" '*' -d "./shellcheck-${sc_ver?}/" || annotate_error 4
        else
          tar -xf "${archive_name?}" || annotate_error 4
        fi
        mv -f "./shellcheck-${sc_ver?}/shellcheck"* "${action_path?}/" || annotate_error 5
        rm -f "./${archive_name?}"; rm -rf "./shellcheck-${sc_ver?}"
    - name: "Display ShellCheck version"
      shell: bash
      run: |
        # Displaying ShellCheck version...
        "${{ github.action_path }}/shellcheck" --version
    - name: "Execute ShellCheck scan"
      id: 'shellcheck-scan'
      shell: bash {0}
      run: |
        # Executing ShellCheck scan...
        SHELLCHECK_OPTS="--color --severity=${{ inputs.severity }}"
        if test "${{ inputs.enable-all-opt-checks }}" != 'false'; then SHELLCHECK_OPTS+=" --enable=all"; fi
        if test "${{ github.event_name }}" != 'pull_request'; then SHELLCHECK_OPTS+=" -x"; fi
        export SHELLCHECK_OPTS

        ignore_string="${{ inputs.ignore-files }}"
        ignore_list=()
        if test -n "$ignore_string"; then
          OLDIFS="$IFS"
          IFS='|'
          read -ra ignore_list <<< "${ignore_string}"
          IFS="$OLDIFS"
        fi

        scan_files()
        {
          files_with_issues='0'
          path_of_files_with_issues=()
          escaped_csi="$(printf '\033\[')"
          set -o pipefail
          while read -r FILE; do
            echo '################################################################################'
            FILE_LOWER="$(echo "${FILE}" | tr '[:upper:]' '[:lower:]')"
            to_ignore=false
            for ELEM in "${ignore_list[@]}"; do
              if [[ "${FILE}" == *"/${ELEM}" ]]; then to_ignore=true; break; fi
            done

            if $to_ignore; then
              echo "Ignored: $FILE"
            elif expr "$FILE_LOWER" : '^.*\.\(sh\|bash\|ash\|dash\|ksh\)$' 1>/dev/null || test '#!' = "$(head -c 2 "$FILE")"; then
              echo "Currently scanning: $FILE"
              if test "${{ runner.os }}" = 'Windows'; then
                "${{ github.action_path }}/shellcheck" "$FILE" | tr -d '\r' | sed -e "s/^\(${escaped_csi}[02-9][0-9]\?m\)/\t\1/"; STATUS="$?"
              else
                "${{ github.action_path }}/shellcheck" "$FILE" | sed -e "s/^\(${escaped_csi}[02-9][0-9]\?m\)/\t\1/"; STATUS="$?"
              fi
              if test "${STATUS}" -ne 0; then files_with_issues="$((files_with_issues+1))"; path_of_files_with_issues+=("$FILE"); fi
            else
              echo "Skipped: $FILE"
            fi
          done

          echo "::set-output name=numfileswithissues::${files_with_issues}"
          echo "::set-output name=pathfileswithissues::${path_of_files_with_issues[@]}"; unset path_of_files_with_issues
          return "${files_with_issues}"
        }
        find '.' -type f \! -path './.git/*' | LC_ALL=C sort | scan_files; num_files_with_issues="$?"

        printf '################################################################################\n\n'
        if test "${num_files_with_issues}" -gt '0'; then
          echo "::error::[ShellChecker] NUMBER OF FILES WITH ISSUES: ${num_files_with_issues} üêõ"
        else
          echo "::notice::[ShellChecker] NUMBER OF FILES WITH ISSUES: ${num_files_with_issues} ‚úÖ"
          printf "\033[32mAll is good!\n"
        fi
    - name: "Display ShellCheck summary"
      shell: bash
      run: |
        # Displaying ShellCheck summary...
        echo "Number of files with issues: ${{ steps.shellcheck-scan.outputs.numfileswithissues }}"
        echo "List of files with issues: ${{ steps.shellcheck-scan.outputs.pathfileswithissues }}"
        exit "${{ steps.shellcheck-scan.outputs.numfileswithissues }}"
